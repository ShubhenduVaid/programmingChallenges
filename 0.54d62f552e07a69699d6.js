(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{Kh5z:function(n,e,t){"use strict";t.r(e);var i={};t.d(i,"findTheLeader",function(){return w}),t.d(i,"findBinaryGap",function(){return A}),t.d(i,"findTopBrands",function(){return v}),t.d(i,"arrayRotation",function(){return N}),t.d(i,"oddOccurances",function(){return L}),t.d(i,"frogJump",function(){return C}),t.d(i,"findMissingElement",function(){return j}),t.d(i,"findTapeEquilibrium",function(){return O}),t.d(i,"findFrequentWord",function(){return X}),t.d(i,"bracesCheck",function(){return B});var o,r=t("CcnG"),a=t("mrSG"),s=new r.p("NGX_MONACO_EDITOR_CONFIG"),l=!1,u=function(){function n(n){this.config=n,this.onInit=new r.n}return Object.defineProperty(n.prototype,"options",{get:function(){return this._options},set:function(n){this._options=Object.assign({},this.config.defaultOptions,n),this._editor&&(this._editor.dispose(),this.initMonaco(n))},enumerable:!0,configurable:!0}),n.prototype.ngAfterViewInit=function(){var n=this;l?o.then(function(){n.initMonaco(n.options)}):(l=!0,o=new Promise(function(e){var t=n.config.baseUrl||"/assets";if("object"!=typeof window.monaco){var i=function(){window.require.config({paths:{vs:t+"/monaco/vs"}}),window.require(["vs/editor/editor.main"],function(){"function"==typeof n.config.onMonacoLoad&&n.config.onMonacoLoad(),n.initMonaco(n.options),e()})};if(window.require)i();else{var o=document.createElement("script");o.type="text/javascript",o.src=t+"/monaco/vs/loader.js",o.addEventListener("load",i),document.body.appendChild(o)}}else e()}))},n.prototype.ngOnDestroy=function(){this._windowResizeSubscription&&this._windowResizeSubscription.unsubscribe(),this._editor&&(this._editor.dispose(),this._editor=void 0)},n}(),d=t("bne5"),c=function(n){function e(e,t){var i=n.call(this,t)||this;return i.zone=e,i.editorConfig=t,i._value="",i.propagateChange=function(n){},i.onTouched=function(){},i}return Object(a.c)(e,n),Object.defineProperty(e.prototype,"model",{set:function(n){this.options.model=n,this._editor&&(this._editor.dispose(),this.initMonaco(this.options))},enumerable:!0,configurable:!0}),e.prototype.writeValue=function(n){var e=this;this._value=n||"",setTimeout(function(){e._editor&&!e.options.model&&e._editor.setValue(e._value)})},e.prototype.registerOnChange=function(n){this.propagateChange=n},e.prototype.registerOnTouched=function(n){this.onTouched=n},e.prototype.initMonaco=function(n){var e=this,t=!!n.model;t&&(n.model=monaco.editor.createModel(n.model.value,n.model.language,n.model.uri)),this._editor=monaco.editor.create(this._editorContainer.nativeElement,n),t||this._editor.setValue(this._value),this._editor.onDidChangeModelContent(function(n){var t=e._editor.getValue();e.propagateChange(t),e.zone.run(function(){return e._value=t})}),this._editor.onDidBlurEditor(function(n){e.onTouched()}),this._windowResizeSubscription&&this._windowResizeSubscription.unsubscribe(),this._windowResizeSubscription=Object(d.a)(window,"resize").subscribe(function(){return e._editor.layout()}),this.onInit.emit(this._editor)},Object(a.b)([Object(a.d)(1,Object(r.o)(s))],e)}(u),h=function(){function n(){}return e=n,n.forRoot=function(n){return void 0===n&&(n={}),{ngModule:e,providers:[{provide:s,useValue:n}]}},n;var e}(),f=function(){},m=t("pMnS"),p=t("NcP4"),g=t("gIcY"),b=r.Na({encapsulation:0,styles:["[_nghost-%COMP%] {\n      display: block;\n      height: 200px;\n    }\n\n    .editor-container[_ngcontent-%COMP%] {\n      width: 100%;\n      height: 98%;\n    }"],data:{}});function y(n){return r.hb(0,[r.db(402653184,1,{_editorContainer:0}),(n()(),r.Pa(1,0,[[1,0],["editorContainer",1]],null,0,"div",[["class","editor-container"]],null,null,null,null,null))],null,null)}var x=t("/Qfb"),w="\nFind the no in a ascending sorted array with max count. Function should return count and no. \n\nlet arr = [1, 1, 1, 1, 1, 2, 2, 3, 4, 4, 4, 4, 4, 4, 4, 5, 5];\nfunction solution(arr) {\n    let length = arr.length;\n    let currentValue = arr[0];\n    let counter = 0;\n    let maxCounter = 0;\n    let maxCounterValue = 0;\n    arr.forEach(element => {\n        if (currentValue !== element) {\n            if (counter > maxCounter) {\n                maxCounter = counter;\n                maxCounterValue = currentValue;\n            }\n            counter = 0;\n            currentValue = element;\n        }\n        counter++;\n    });\n    let obj = {};\n    obj[maxCounterValue] = maxCounter\n    return obj;\n}\nconsole.log(solution(arr));\n",A="\nA binary gap within a positive integer N is any maximal sequence of consecutive zeros that is surrounded by ones at both ends in the binary representation of N.\n\nFor example, number 9 has binary representation 1001 and contains a binary gap of length 2. The number 529 has binary representation 1000010001 and contains two binary gaps: one of length 4 and one of length 3. The number 20 has binary representation 10100 and contains one binary gap of length 1. The number 15 has binary representation 1111 and has no binary gaps. The number 32 has binary representation 100000 and has no binary gaps.\n\nWrite a function:\n\nfunction solution(N);\n\nthat, given a positive integer N, returns the length of its longest binary gap. The function should return 0 if N doesn't contain a binary gap.\n\nFor example, given N = 1041 the function should return 5, because N has binary representation 10000010001 and so its longest binary gap is of length 5. Given N = 32 the function should return 0, because N has binary representation '100000' and thus no binary gaps.\n\nAssume that:\n\nN is an integer within the range [1..2,147,483,647].\nComplexity:\n\nexpected worst-case time complexity is O(log(N));\nexpected worst-case space complexity is O(1).\n\nfunction solution(N) {\n    let binaryNo = N.toString(2);\n    let binaryList = binaryNo.split('');\n    let maxCount = 0;\n    let count = 0;\n\tlet startingOne = true;\n\tlet endingOne = false;\n    binaryList.forEach(element => {\n        if(element === '0'){\n            count ++;\n\t\t\tendingOne = false;\n        }\n        else{\n\t\t\tif(count > 0) endingOne = true;\n\t\t\tif(startingOne && endingOne){\n\t\t\t\tmaxCount = (count > maxCount)?count:maxCount;\n\t\t\t}\n            count = 0;\n        }\n    });\n    return maxCount;\n};\nconsole.log(solution(42));\nconsole.log(solution(1041));\nconsole.log(solution(32));\n",v='\nYou would like to make a list of N top brand names based on user preferences. You are supplied with data about users containing id and gender information.\nThe method of compiling the list of N top brand names is as follows:\n1. If the user specifies enough liked brands to cover the required N brands, then only this information should be used.\n   Liked brands can be accessed by calling the function getlikedBrands(id). If the user specifies more than N liked brands, then the first N brand names returned by getLikedBrands (id) shauld be used \n2. If the user doesnt mention enough liked brands, then the rest of the result list should be filled up with top brands for the user\'s gender. Such a list can be obtained by calling the function getTopBrandsForGender(gender). \n   If getTopBrandsForGender(gender) retums more brand names than are needed to complete the list, as many of the leading brand names as are needed should be used. \n3. The order of the brand names in the result list should be the same as the order in the lists given by the functions, with brand names returned by getlikedBrands (id) listed first. \n   Brand names returned by both functions together, getLikedBrands (id) and getTopBrandsForGender(gender), should appear only once.\n\nWrite a function: \nfunction solution(U, N); \nthat, given user U and the number of brand names N, returns a Promise that should either be:\n * resolved with an array of exactly N top brand names of the given user, in the following format: ["Some Brand Name", "other Brand Name",..]; \n * or rejected with an CustomError with a message "Not enough data" (if there are fewer than N brand names to be listed, or both Promises getlikedBrands (id) and getTopBrandsForGender (gender) are rejected)\n\nThe user parameter is an object of the following structure: {id: 123132, gender: "FEMALE"} , where id is an integer and gendder is a string containing \'FEMALE\' and \'MALE\'.\n\nThe functions getLikedBrands(id) and getTopBrandsForGender(gender), used in the algorithm above, return Promises that will be rejected with an CustomError or resolved with data in the following format:\n [{id: 123, nameSome Brand Name"} , {id: 456, name: Other Brand Name}]"\n\n For example, given user U, assume that getLikedBrands (U. id) returns [{1, "Logestyx}, {1, Gladlear}] and getTopBrandsForGender(U. gender) returns [{6, "Burylaze Slapgalt}, {l, "Logestyx"},{17,"Izarpure}]\n\nFor N=1 your function should return a Promise which resolves with an array ["Logestyx"]. \nFor N=3 Promise should be resoived with an array ["Logestyx", "Gladlear", "Burylaze Slapgalt"]\nFor N=5 Promise should be rejected with an CustomError.\nThe solution should be optimized for client-side (browser-based) performance, rather than back-end load.\nThe expectation is that the developer will call both functions in parallel.\n\n\nSolution:\n\n\'use strict\';\n\nfunction getLikedBrands(id) {\n    return new Promise((resolve, reject) => {\n        let likeBrandList = [\n            {\n                id: 1,\n                name: \'Logestyx\'\n            },\n            {\n                id: 10,\n                name: \'Gladlear\'\n            }\n        ];\n        resolve(likeBrandList);\n    });\n};\n\nfunction getTopBrandsForGender(gender) {\n    return new Promise((resolve, reject) => {\n        let genderBrandList = [\n            {\n                id: 6,\n                name: \'Burylaze Slapgalt\'\n            },\n            {\n                id: 1,\n                name: \'Logestyx\'\n            },\n            {\n                id: 7,\n                name: \'Izarpure\'\n            }\n        ];\n        resolve(genderBrandList);\n    });\n};\n\nfunction solution(U, N) {\n    return new Promise((resolve, reject) => {\n        let likedBrandsList = [];\n        let finalBrandslist = [];\n        let error = "Not enough data";\n        Promise.all([getLikedBrands(U.id), getTopBrandsForGender(U.gender)])\n            .then(function (data) {\n                likedBrandsList = [...data[0], ...data[1]];\n                likedBrandsList = removeDuplicates(likedBrandsList);\n                finalBrandslist = finalBrandsList(likedBrandsList);\n                if (finalBrandslist.length < N) {\n                    reject(error);\n                }\n                else {\n                    resolve(finalBrandslist.splice(0, N));\n                };\n            })\n            .catch(function (error) {\n                reject(error);\n            });\n    });\n};\n\nlet U = { id: 1, gender: \'FEMALE\' };\nlet N = 1;\nsolution(U, N).then((data) => {\n    console.log(data);\n}).catch((error) => {\n    console.log(error);\n});\n\nfunction removeDuplicates(arr) {\n    let obj = {};\n    let likeList = [];\n    for (let index = 0; index < arr.length; index++) {\n        const element = arr[index];\n        if(obj[element.id] === undefined){\n            likeList.push(element);\n        }\n        obj[element.id] = \'\';\n    }\n    return likeList;\n};\n\nfunction finalBrandsList(arr) {\n    let likeList = [];\n    arr.forEach(element => {\n        likeList.push(element.name);\n    });\n    return likeList;\n};\n\n',N="\nAn array A consisting of N integers is given. Rotation of the array means that each element is shifted right by one index, and the last element of the array is moved to the first place. For example, the rotation of array A = [3, 8, 9, 7, 6] is [6, 3, 8, 9, 7] (elements are shifted right by one index and 6 is moved to the first place).\n\nThe goal is to rotate array A K times; that is, each element of A will be shifted to the right K times.\n\nWrite a function:\n\nfunction solution(A, K);\n\nthat, given an array A consisting of N integers and an integer K, returns the array A rotated K times.\n\nFor example, given\n\n    A = [3, 8, 9, 7, 6]\n    K = 3\nthe function should return [9, 7, 6, 3, 8]. Three rotations were made:\n\n    [3, 8, 9, 7, 6] -> [6, 3, 8, 9, 7]\n    [6, 3, 8, 9, 7] -> [7, 6, 3, 8, 9]\n    [7, 6, 3, 8, 9] -> [9, 7, 6, 3, 8]\nFor another example, given\n\n    A = [0, 0, 0]\n    K = 1\nthe function should return [0, 0, 0]\n\nGiven\n\n    A = [1, 2, 3, 4]\n    K = 4\nthe function should return [1, 2, 3, 4]\n\nAssume that:\n\nN and K are integers within the range [0..100];\neach element of array A is an integer within the range [\u22121,000..1,000].\nIn your solution, focus on correctness. The performance of your solution will not be the focus of the assessment.\n\nfunction solution(A, K) {\n    let arrayLength = A.length;\n    // TO counter for case when rotation length > array length.\n    let rotationTimes = (K <= arrayLength)?K:(K%arrayLength);\n    let maxIndex = arrayLength - 1;\n    let rotatedList = [];\n    for (let index = 0; index < arrayLength; index++) {\n      let newIndex = index + rotationTimes;\n      if (newIndex > maxIndex) {\n        newIndex = newIndex - maxIndex - 1;\n      }\n      rotatedList[newIndex] = A[index];\n    }\n    return rotatedList;\n  };\n  \n  let A = [1,2,3,4];\n  \n  let K = 5;\n  \n  console.log(solution(A, K));\n",L="\nA non-empty array A consisting of N integers is given. The array contains an odd number of elements, and each element of the array can be paired with another element that has the same value, except for one element that is left unpaired.\n\nFor example, in array A such that:\n\n  A[0] = 9  A[1] = 3  A[2] = 9\n  A[3] = 3  A[4] = 9  A[5] = 7\n  A[6] = 9\nthe elements at indexes 0 and 2 have value 9,\nthe elements at indexes 1 and 3 have value 3,\nthe elements at indexes 4 and 6 have value 9,\nthe element at index 5 has value 7 and is unpaired.\nWrite a function:\n\nint solution(int A[], int N);\n\nthat, given an array A consisting of N integers fulfilling the above conditions, returns the value of the unpaired element.\n\nFor example, given array A such that:\n\n  A[0] = 9  A[1] = 3  A[2] = 9\n  A[3] = 3  A[4] = 9  A[5] = 7\n  A[6] = 9\nthe function should return 7, as explained in the example above.\n\nAssume that:\n\nN is an odd integer within the range [1..1,000,000];\neach element of array A is an integer within the range [1..1,000,000,000];\nall but one of the values in A occur an even number of times.\nComplexity:\n\nexpected worst-case time complexity is O(N);\nexpected worst-case space complexity is O(1) (not counting the storage required for input arguments).\n\nfunction solution(A) {\n    let outputMap = {};\n    A.forEach((element) => {\n       if(outputMap[element] === undefined){\n            outputMap[element] = 1;    \n       }\n       else{\n           if(outputMap[element] === 1){\n                outputMap[element] = 2;\n           }\n           else if(outputMap[element] === 2){\n                outputMap[element] = 1;\n           }\n       }\n    });\n    let objList = Object.keys(outputMap);\n    let arrLength = objList.length;\n    let lonelyNo = 0;\n    for(let index = 0; index < arrLength ; index++){\n        if(outputMap[objList[index]] === 1){\n            lonelyNo = objList[index];\n        }\n    }\n    return parseInt(lonelyNo);\n}\n",C="\nA small frog wants to get to the other side of the road. The frog is currently located at position X and wants to get to a position greater than or equal to Y. The small frog always jumps a fixed distance, D.\n\nCount the minimal number of jumps that the small frog must perform to reach its target.\n\nWrite a function:\n\nfunction solution(X, Y, D);\n\nthat, given three integers X, Y and D, returns the minimal number of jumps from position X to a position equal to or greater than Y.\n\nFor example, given:\n\n  X = 10\n  Y = 85\n  D = 30\nthe function should return 3, because the frog will be positioned as follows:\n\nafter the first jump, at position 10 + 30 = 40\nafter the second jump, at position 10 + 30 + 30 = 70\nafter the third jump, at position 10 + 30 + 30 + 30 = 100\nAssume that:\n\nX, Y and D are integers within the range [1..1,000,000,000];\nX \u2264 Y.\nComplexity:\n\nexpected worst-case time complexity is O(1);\nexpected worst-case space complexity is O(1).\n\nfunction solution(X, Y, D) {\n    // write your code in JavaScript (Node.js 8.9.4)\n    let difference = Y - X;\n    let minJumps = 0;\n    if(difference === 0){\n        return minJumps;   \n    }\n    else{\n        let factor = difference % D;                  \n        if(factor === 0){\n            minJumps = difference / D;\n            return minJumps;    \n        }\n        else{\n            return Math.floor(difference / D) + 1;\n        }\n    }\n}\n",j="\nAn array A consisting of N different integers is given. The array contains integers in the range [1..(N + 1)], which means that exactly one element is missing.\n\nYour goal is to find that missing element.\n\nWrite a function:\n\nfunction solution(A);\n\nthat, given an array A, returns the value of the missing element.\n\nFor example, given array A such that:\n\n  A[0] = 2\n  A[1] = 3\n  A[2] = 1\n  A[3] = 5\nthe function should return 4, as it is the missing element.\n\nAssume that:\n\nN is an integer within the range [0..100,000];\nthe elements of A are all distinct;\neach element of array A is an integer within the range [1..(N + 1)].\nComplexity:\n\nexpected worst-case time complexity is O(N);\nexpected worst-case space complexity is O(1) (not counting the storage required for input arguments).\n\nfunction solution(A) {\n    // write your code in JavaScript (Node.js 8.9.4)\n    let sortedList = A.sort((a,b) => a - b);\n    let currentElement = sortedList[0];\n    for(let i = 1; i < sortedList.length; i++){\n        if(sortedList[i] - currentElement > 1){\n            return (currentElement + 1); \n        }\n        currentElement = sortedList[i];\n    }\n}\n\nfunction solution(A) {\n    // write your code in JavaScript (Node.js 4.0.0)\n    A.sort(function(a, b) {\n        return a - b;\n    });\n    \n    var next = 1;\n    var i=0;\n    while(next === A[i]) {\n        next++;\n        i++;\n    }\n    \n    return next;\n}\n\n",O="\nA non-empty array A consisting of N integers is given. Array A represents numbers on a tape.\n\nAny integer P, such that 0 < P < N, splits this tape into two non-empty parts: A[0], A[1], ..., A[P \u2212 1] and A[P], A[P + 1], ..., A[N \u2212 1].\n\nThe difference between the two parts is the value of: |(A[0] + A[1] + ... + A[P \u2212 1]) \u2212 (A[P] + A[P + 1] + ... + A[N \u2212 1])|\n\nIn other words, it is the absolute difference between the sum of the first part and the sum of the second part.\n\nFor example, consider array A such that:\n\n  A[0] = 3\n  A[1] = 1\n  A[2] = 2\n  A[3] = 4\n  A[4] = 3\nWe can split this tape in four places:\n\nP = 1, difference = |3 \u2212 10| = 7 \nP = 2, difference = |4 \u2212 9| = 5 \nP = 3, difference = |6 \u2212 7| = 1 \nP = 4, difference = |10 \u2212 3| = 7 \nWrite a function:\n\nfunction solution(A);\n\nthat, given a non-empty array A of N integers, returns the minimal difference that can be achieved.\n\nFor example, given:\n\n  A[0] = 3\n  A[1] = 1\n  A[2] = 2\n  A[3] = 4\n  A[4] = 3\nthe function should return 1, as explained above.\n\nAssume that:\n\nN is an integer within the range [2..100,000];\neach element of array A is an integer within the range [\u22121,000..1,000].\nComplexity:\n\nexpected worst-case time complexity is O(N);\nexpected worst-case space complexity is O(N) (not counting the storage required for input arguments).\n\n\n",X='\nFind the most frequent word in the Array\n\nfunction solution(A) {\n    let obj = {};\n    A.forEach(element => {\n        if (obj[element] === undefined) {\n            obj[element] = 1;\n        }\n        else {\n            obj[element] = parseInt(obj[element]) + 1;\n        }\n    });\n    let uniqueWordsList = Object.keys(obj);\n    let freqWord = \'No frequent word\';\n    let maxCount = 1;\n    uniqueWordsList.forEach(element => {\n        if (maxCount < obj[element]) {\n            maxCount = obj[element];\n            freqWord = element;\n        }\n    });\n    return freqWord;\n};\n// O(n) time and space;\nlet list = ["my", "name", "is", "chu", "bansal.", "bansal", "is", "my", "last", "name"];\nconsole.log(solution(list));\n',B="\nCheck for braces [,{,( and ],},) in an expression.\n\nlet expression = '{789+={]}';\n\nconsole.log(checkExpression(expression));\n\nfunction checkExpression(expression) {\n    let openBraces = { '(': 0, '{': 0, '[': 0 };\n    let closeBraces = { ')': 0, '}': 0, ']': 0 };\n    let relationObj = {\n        ')': '(',\n        '}': '{',\n        ']': '['\n    };\n    let bracesStack = [];\n    const EMPTY = 'Expression is empty.';\n    const WRONG = 'Expression is wrong.';\n    const CORRECT = 'Expression is correct.';\n    if (expression.length === 0) {\n        return EMPTY;\n    }\n    for (let index = 0; index < expression.length; index++) {\n        const element = expression[index];\n        if (openBraces[element] !== undefined) {\n            bracesStack.push(element);\n        }\n        else if (closeBraces[element] !== undefined) {\n            if (relationObj[element] !== bracesStack.pop()) {\n                return WRONG;\n            }\n        }\n    }\n    if (bracesStack.length === 0) {\n        return CORRECT;\n    }\n    else {\n        return WRONG;\n    }\n}\n",k=function(){function n(n){this.route=n,this.editorOptions={},this.code=""}return n.prototype.ngOnInit=function(){this._id=this.route.snapshot.params.id,this.setEditorValue()},n.prototype.setEditorValue=function(){for(var n=0;n<x.a.length;n++)if(x.a[n].id===this._id){this.record=x.a[n];break}this.code=i[this.record.link],this.editorOptions={theme:"vs-dark",language:this.record.language.toLowerCase()}},n}(),T=t("ZYCi"),P=r.Na({encapsulation:0,styles:[[""]],data:{}});function E(n){return r.hb(0,[(n()(),r.Pa(0,0,null,null,5,"ngx-monaco-editor",[],[[2,"ng-untouched",null],[2,"ng-touched",null],[2,"ng-pristine",null],[2,"ng-dirty",null],[2,"ng-valid",null],[2,"ng-invalid",null],[2,"ng-pending",null]],[[null,"ngModelChange"]],function(n,e,t){var i=!0;return"ngModelChange"===e&&(i=!1!==(n.component.code=t)&&i),i},y,b)),r.Oa(1,4374528,null,0,c,[r.y,s],{options:[0,"options"]},null),r.cb(1024,null,g.c,function(n){return[n]},[c]),r.Oa(3,671744,null,0,g.g,[[8,null],[8,null],[8,null],[6,g.c]],{model:[0,"model"]},{update:"ngModelChange"}),r.cb(2048,null,g.d,null,[g.g]),r.Oa(5,16384,null,0,g.e,[[4,g.d]],null,null)],function(n,e){var t=e.component;n(e,1,0,t.editorOptions),n(e,3,0,t.code)},function(n,e){n(e,0,0,r.Za(e,5).ngClassUntouched,r.Za(e,5).ngClassTouched,r.Za(e,5).ngClassPristine,r.Za(e,5).ngClassDirty,r.Za(e,5).ngClassValid,r.Za(e,5).ngClassInvalid,r.Za(e,5).ngClassPending)})}var M=r.La("app-challenge",k,function(n){return r.hb(0,[(n()(),r.Pa(0,0,null,null,1,"app-challenge",[],null,null,null,E,P)),r.Oa(1,114688,null,0,k,[T.a],null,null)],function(n,e){n(e,1,0)},null)},{},{},[]),_=t("Ip0R"),F=t("Wf4p"),I=t("eDkP"),q=t("Fzqc"),S=t("uGex"),G=t("M2Lx"),W=t("v9Dh"),D=t("4epT"),K=t("OkvK"),z=t("y4qS"),R=t("BHnd"),V=t("dWZg"),Y=t("UodH"),U=t("seP3"),J=t("/VYK"),Z=t("b716"),H=t("4c35"),Q=t("qAlS"),$=t("lLAP"),nn=t("hctd"),en=t("PCNd");t.d(e,"ChallengeModuleNgFactory",function(){return tn});var tn=r.Ma(f,[],function(n){return r.Wa([r.Xa(512,r.j,r.Ba,[[8,[m.a,p.a,M]],[3,r.j],r.w]),r.Xa(4608,_.m,_.l,[r.t,[2,_.w]]),r.Xa(4608,F.d,F.d,[]),r.Xa(4608,I.c,I.c,[I.h,I.d,r.j,I.g,I.e,r.q,r.y,_.d,q.b]),r.Xa(5120,I.i,I.j,[I.c]),r.Xa(5120,S.a,S.b,[I.c]),r.Xa(4608,G.a,G.a,[]),r.Xa(5120,W.b,W.c,[I.c]),r.Xa(5120,D.c,D.a,[[3,D.c]]),r.Xa(5120,K.d,K.a,[[3,K.d]]),r.Xa(4608,g.i,g.i,[]),r.Xa(1073742336,T.l,T.l,[[2,T.r],[2,T.k]]),r.Xa(1073742336,_.c,_.c,[]),r.Xa(1073742336,z.p,z.p,[]),r.Xa(1073742336,q.a,q.a,[]),r.Xa(1073742336,F.l,F.l,[[2,F.e]]),r.Xa(1073742336,R.m,R.m,[]),r.Xa(1073742336,V.b,V.b,[]),r.Xa(1073742336,F.u,F.u,[]),r.Xa(1073742336,Y.c,Y.c,[]),r.Xa(1073742336,U.d,U.d,[]),r.Xa(1073742336,J.c,J.c,[]),r.Xa(1073742336,Z.b,Z.b,[]),r.Xa(1073742336,H.c,H.c,[]),r.Xa(1073742336,Q.a,Q.a,[]),r.Xa(1073742336,I.f,I.f,[]),r.Xa(1073742336,F.s,F.s,[]),r.Xa(1073742336,F.q,F.q,[]),r.Xa(1073742336,S.d,S.d,[]),r.Xa(1073742336,G.b,G.b,[]),r.Xa(1073742336,$.a,$.a,[]),r.Xa(1073742336,W.e,W.e,[]),r.Xa(1073742336,D.d,D.d,[]),r.Xa(1073742336,K.e,K.e,[]),r.Xa(1073742336,nn.a,nn.a,[]),r.Xa(1073742336,g.h,g.h,[]),r.Xa(1073742336,g.b,g.b,[]),r.Xa(1073742336,en.a,en.a,[]),r.Xa(1073742336,h,h,[]),r.Xa(1073742336,f,f,[]),r.Xa(1024,T.i,function(){return[[{path:"",component:k}]]},[]),r.Xa(256,s,{},[])])})}}]);